508 The process of code generation usually involves multiple passes that gradually substitute machine-specific code and data for the information in the parse tree.  An important consideration in modern compilers is optimization  which is the process of substituting equivalent (but more efficient) constructs for the original output of the front end.  For example  an optimizer can replace an arithmetic expression with its value so that it need not be repeatedly calculated while the program is running.  It can also â€œhoist outâ€ an invariant expression from a loop so that it is calculated only once before the loop begins.  On a larger scale  optimization can also improve the communication between different parts (procedures) of the program. The compiler must attempt to â€œproveâ€ that the change it is making in the program will never cause the program to operate incorrectly.  It can do this  for example  by tracing the possible paths of execution through the program (such as through branching and loops) and verifying that each possible path yields the correct result.  A compiler that is too â€œaggressiveâ€ in making assumptions can produce subtle program errors.  (Many compilers allow the user to control the level of optimization  and whether to optimize for speed or for compactness of program size. ) During development  a compiler is often set to include special debugging code in the output.  This code preserves potentially important information that can help the debugging facility better identify program bugs.  After the program is working correctly  it will be recompiled without the debugging code 
