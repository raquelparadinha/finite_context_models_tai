A computer consists of CPU and memory . Memory is the simpler chip to understand -- memory consists of a large array of * memory cells * , each of which can contain a 0 or a 1 ( a single bit ) . The cells are divided into groups of 8 , each group can contain 8 bits ( one byte ) . Each 8 - bit group is numbered with an * address * which is simply a number ( coded in binary ) that identifies the cell . So for example , the CPU can tell memory " write 00101101 into cell number 1493 " . Then at a later point in time , the computer can tell memory " read the contents of cell number 1493 " and memory will respond with " 00101101 " . The address 1493 is itself coded as a sequence of bits , so the CPU would actually say " read / write the contents of cell number 0000010111010101 " . A typical CPU / memory interface consists of a number of * lines * which are several copper wires that physically connect the CPU to the memory : - Address lines . The CPU puts the coded address of the cell it wants to work with ( such as 0000010111010101 ) on these 16 lines . - Data lines . The data ( 00101101 ) goes on these 8 lines . In the case of writing data into memory , the CPU sets the data lines . In the case of reading data from memory , the memory sets the data lines . - R / W bit . A single line which the CPU sets to 0 when it wants to read from memory , 1 when it wants to write to memory . - Clock . Pulses on this line dictate the timing of exactly when the memory / CPU should read / write the address / data lines . How quickly the clock pulses occur determines how quickly memory can be read / written . Making it faster increases system performance , but also increases the physical speed requirements of the CPU / memory chips . The CPU works by reading memory at the program counter , executing the instruction based on what it does , and incrementing the program counter to get it to the next instruction . For example , 37 might be the code for " load the number 0 into register A " , the 3 - byte sequence 87 21 63 might be the code for " load the number 6321 into register B " , 88 34 14 might be the code for " load the number 3414 into register C " and 22 might be the code for " add register A to register C , then store the result in register A. " ( A * register * is a small number of memory cell circuits inside the CPU which serve as a " scratch pad " or " short term memory " for the CPU to store values internally . ) If we wanted to do these things in a program , it would be 37 87 21 63 88 34 14 22 which would go into consecutive memory cells . Let 's put 37 87 21 63 88 34 14 22 into memory cells at addresses 2100 , 2101 , 2102 , 2103 , etc . then set the PC to 2100 , and let the CPU run . The CPU reads a 37 from address 2100 , increments PC to 2101 and executes the instruction to set register A to 0 . PC is now 2101 , so the CPU reads an 87 from address 2101 , increments PC to 2102 , sees that 87 is code for a three - byte instruction , fetches the first additional byte 21 from PC ( which is 2102 ) , increments PC to 2103 , fetches a second additional byte 63 from PC , increments PC to 2104 . The CPU now has the three bytes needed for the second instruction and loads 6321 into register B. The CPU keeps on doing this fetch - decode - execute loop forever ( or until powered down ) . Now that you know how CPU and memory work , the boot process is simple : Physically hard wired in the CPU is a number called a * reset vector * ( like all numbers in a computer , it 's coded in binary ) . Upon system power - up or reset , the CPU copies the reset vector into the program counter . It 's up to the system designer to include a memory chip which will respond to the reset vector address and contain a useful program . On the PC , this memory chip is called * BIOS * . The initial chip is referred to as a ROM ( read only memory ) , because in the early days it was literally hard wired with the program . In modern times ROM 's are flash chips ( the technology in USB disks , smart phones and modern SSD hard drives ) , so the ROM is n't truly " read only " ( it can be written to ) , but it 's still called ROM to distinguish it from " ordinary " memory or RAM ( which is much faster , but loses data when powered down ) . Now your second question : How code communicates with hardware . As well as being connected to memory , the CPU has extra pins which can be connected to other devices . There are CPU instructions to read and write the electrical state of these pins . There are a number of standardized communication methods for sending data over these extra pins ( serial , SPI , I2C , ISA , PCI ) . Also you can have devices which are n't memory cells connected to the memory bus and respond to memory addresses ( " memory - mapped I / O " ) . So really the heart of the computer is the CPU + memory which makes it possible to execute a program consisting of stored instructions . For everything else you just need a physical connection to the CPU and a way to access that connection from the software level of stored instructions . The vast array of devices in a typical computer -- screens and keyboards to communicate with humans , networking to communicate with other computers , hard drives to store gobs of data permanently , speakers , video camera , microphone -- they 're all just literally separate devices that are electronically designed to be computer controlled and mechanically designed to fit snugly in the same case ( or on the same circuit board ) as the CPU / memory.